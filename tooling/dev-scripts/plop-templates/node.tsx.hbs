/**
 * {{titleCase kind}} NODE - Clean content-focused node template
 *
 * • Focuses ONLY on content and layout - no structural styling
 * • withNodeScaffold handles all borders, sizing, theming, interactive states
 * • Schema-driven controls in Node Inspector
 * • Type-safe data validation with Zod schema
 * • Clean separation of concerns for maximum maintainability
 * • Comprehensive data type handling for future-proof data flow
 *
 * Keywords: {{kebabCase kind}}, content-focused, schema-driven, type-safe, clean-architecture, data-propagation
 */

import React, { useCallback, useEffect, useState, useRef } from 'react';
import { NodeProps, useReactFlow, useNodes, useEdges } from '@xyflow/react';
import { z } from 'zod';
import { withNodeScaffold } from '@/features/business-logic-modern/infrastructure/node-core/withNodeScaffold';
import { NodeSpec } from '@/features/business-logic-modern/infrastructure/node-core/NodeSpec';
import {
  createNodeValidator,
  CommonSchemas,
  reportValidationError,
  useNodeDataValidation
} from '@/features/business-logic-modern/infrastructure/node-core/validation';
import { SafeSchemas, createSafeInitialData } from '@/features/business-logic-modern/infrastructure/node-core/schema-helpers';
import { CATEGORIES } from '@/features/business-logic-modern/infrastructure/theming/categories';
import { EXPANDED_SIZES, COLLAPSED_SIZES } from '@/features/business-logic-modern/infrastructure/theming/sizing';
import { ExpandCollapseButton } from '@/components/nodes/ExpandCollapseButton';
import { useNodeData } from '@/hooks/useNodeData';

// -- PLOP-INJECTED-IMPORTS --

/**
 * Data schema for {{titleCase kind}} node
 * Define your node's data structure - controls are automatically generated
 */
const {{pascalCase kind}}DataSchema = z.object({
  // Basic fields - customize as needed
  text: SafeSchemas.text('Default text'),
  isEnabled: SafeSchemas.boolean(true),
  isActive: SafeSchemas.boolean(false),
  isExpanded: SafeSchemas.boolean(false),
  {{#if (eq dataPropagation "input")}}
  receivedData: SafeSchemas.optionalText(), // Store received data from connected nodes
  {{/if}}
  {{#if (eq dataPropagation "both")}}
  receivedData: SafeSchemas.optionalText(), // Store received data from connected nodes
  {{/if}}

  // Dynamic size fields for node inspector controls
  expandedSize: SafeSchemas.text('{{expandedSize}}'), // Dynamic expanded size
  collapsedSize: SafeSchemas.text('{{collapsedSize}}'), // Dynamic collapsed size

  // Add your fields here - controls are auto-generated:
  // description: SafeSchemas.optionalText(),
  // count: SafeSchemas.number(1, 1, 100),
  // priority: SafeSchemas.enum(['low', 'medium', 'high'], 'medium'),
}).passthrough();

type {{pascalCase kind}}Data = z.infer<typeof {{pascalCase kind}}DataSchema>;

// Create enterprise validator
const validateNodeData = createNodeValidator({{pascalCase kind}}DataSchema, '{{pascalCase kind}}');

/**
 * Node specification with schema-driven controls
 */
const spec: NodeSpec = {
  kind: '{{camelCase kind}}',
  displayName: '{{camelCase kind}}'.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim(),
  label: '{{camelCase kind}}'.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim(),
  category: CATEGORIES.{{constantCase category}},
  size: {
    expanded: {{expandedSizeConstant expandedSize}},
    collapsed: {{collapsedSizeConstant collapsedSize}},
  },
  handles: [
    { id: 'json-input', code: 'j', position: 'top', type: 'target', dataType: 'JSON' },
    { id: 'output', code: 's', position: 'right', type: 'source', dataType: 'String' },
    { id: 'activate', code: 'b', position: 'left', type: 'target', dataType: 'Boolean' },
  ],
  inspector: {
    key: '{{pascalCase kind}}Inspector',
  },
  version: 1,
  runtime: {
    execute: '{{camelCase kind}}_execute_v1',
  },
  initialData: createSafeInitialData({{pascalCase kind}}DataSchema),
  dataSchema: {{pascalCase kind}}DataSchema,
  controls: {
    autoGenerate: true,
    excludeFields: ["isActive", "receivedData", "expandedSize", "collapsedSize"], // Hide system fields and size fields from main controls
    customFields: [
      {
        key: "isExpanded",
        type: "boolean",
        label: "Expand",
      },
    ],
  },
  icon: '{{icon}}' || 'LuCircle', // Placeholder - update with appropriate Lucide icon
  author: '{{author}}',
  description: '{{description}}',
  feature: '{{feature}}',
  tags: ['{{tags}}'],
  {{#if customTheming}}
  theming: {
    {{#if bgDark}}bgDark: '{{bgDark}}',{{/if}}
    {{#if borderDark}}borderDark: '{{borderDark}}',{{/if}}
    {{#if textDark}}textDark: '{{textDark}}',{{/if}}
  },
  {{/if}}
  {{#if (eq dataPropagation "input")}}
  receivedData: {
    enabled: true,
    displayMode: 'formatted',
    showInCollapsed: true,
    formatData: (data: any) => {
      // Comprehensive data type handling
      if (data === null) return 'null';
      if (data === undefined) return 'undefined';
      if (typeof data === 'string') return data || 'Empty string';
      if (typeof data === 'number') return String(data);
      if (typeof data === 'boolean') return data ? 'true' : 'false';
      if (typeof data === 'bigint') return data.toString();
      if (typeof data === 'symbol') return data.toString();
      if (typeof data === 'function') return '[Function]';
      
      if (typeof data === 'object') {
        if (Array.isArray(data)) {
          if (data.length === 0) return '[] (empty array)';
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Array]';
          }
        } else if (data instanceof Date) {
          return data.toISOString();
        } else if (data instanceof RegExp) {
          return data.toString();
        } else if (data instanceof Error) {
          return `Error: ${data.message}`;
        } else if (data instanceof Map) {
          try {
            return JSON.stringify(Array.from(data.entries()), null, 2);
          } catch {
            return '[Map]';
          }
        } else if (data instanceof Set) {
          try {
            return JSON.stringify(Array.from(data), null, 2);
          } catch {
            return '[Set]';
          }
        } else if (data instanceof Promise) {
          return '[Promise]';
        } else {
          // Handle plain objects with common data properties
          const dataProperties = [
            'text', 'output', 'value', 'data', 'content', 'message', 
            'result', 'response', 'body', 'payload', 'input', 'output'
          ];
          
          for (const prop of dataProperties) {
            if (data[prop] !== null && data[prop] !== undefined) {
              if (typeof data[prop] === 'string') {
                return data[prop] || 'Empty string';
              } else if (typeof data[prop] === 'number') {
                return String(data[prop]);
              } else if (typeof data[prop] === 'boolean') {
                return data[prop] ? 'true' : 'false';
              } else if (typeof data[prop] === 'object') {
                try {
                  return JSON.stringify(data[prop], null, 2);
                } catch {
                  return `[${prop}]`;
                }
              } else {
                return String(data[prop]);
              }
            }
          }
          
          // If no common properties found, stringify the entire object
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Object]';
          }
        }
      }
      
      // Fallback for any other types
      return String(data);
    },
  },
  {{/if}}
  {{#if (eq dataPropagation "both")}}
  receivedData: {
    enabled: true,
    displayMode: 'formatted',
    showInCollapsed: true,
    formatData: (data: any) => {
      // Comprehensive data type handling
      if (data === null) return 'null';
      if (data === undefined) return 'undefined';
      if (typeof data === 'string') return data || 'Empty string';
      if (typeof data === 'number') return String(data);
      if (typeof data === 'boolean') return data ? 'true' : 'false';
      if (typeof data === 'bigint') return data.toString();
      if (typeof data === 'symbol') return data.toString();
      if (typeof data === 'function') return '[Function]';
      
      if (typeof data === 'object') {
        if (Array.isArray(data)) {
          if (data.length === 0) return '[] (empty array)';
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Array]';
          }
        } else if (data instanceof Date) {
          return data.toISOString();
        } else if (data instanceof RegExp) {
          return data.toString();
        } else if (data instanceof Set) {
          try {
            return JSON.stringify(Array.from(data), null, 2);
          } catch {
            return '[Set]';
          }
        } else if (data instanceof Promise) {
          return '[Promise]';
        } else {
          // Handle plain objects with common data properties
          const dataProperties = [
            'text', 'output', 'value', 'data', 'content', 'message', 
            'result', 'response', 'body', 'payload', 'input', 'output'
          ];
          
          for (const prop of dataProperties) {
            if (data[prop] !== null && data[prop] !== undefined) {
              if (typeof data[prop] === 'string') {
                return data[prop] || 'Empty string';
              } else if (typeof data[prop] === 'number') {
                return String(data[prop]);
              } else if (typeof data[prop] === 'boolean') {
                return data[prop] ? 'true' : 'false';
              } else if (typeof data[prop] === 'object') {
                try {
                  return JSON.stringify(data[prop], null, 2);
                } catch {
                  return `[${prop}]`;
                }
              } else {
                return String(data[prop]);
              }
            }
          }
          
          // If no common properties found, stringify the entire object
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Object]';
          }
        }
      }
      
      // Fallback for any other types
      return String(data);
    },
  },
  {{/if}}
};

/**
 * Content-focused styling constants
 * Only handles internal layout and content - no structural styling
 */
const CONTENT_STYLES = {
  // Content area layouts
  content: {
    expanded: "p-4 w-full h-full flex flex-col",
    collapsed: "flex items-center justify-center w-full h-full",
  },

  // Header layouts
  header: {
    container: "flex items-center justify-between mb-3",
  },

  // Main content layouts
  main: {
    container: "flex-1 flex items-center justify-center",
    content: "text-center",
    icon: "text-2xl mb-2",
  },

  // Collapsed state layouts
  collapsed: {
    icon: "text-2xl",
  },
} as const;

/**
 * Category-specific text colors from design system
 */
const CATEGORY_TEXT_COLORS = {
  CREATE: {
    primary: "text-(--node-create-text)",
    secondary: "text-(--node-create-text-secondary)",
  },
  VIEW: {
    primary: "text-(--node-view-text)",
    secondary: "text-(--node-view-text-secondary)",
  },
  TRIGGER: {
    primary: "text-(--node-trigger-text)",
    secondary: "text-(--node-trigger-text-secondary)",
  },
  TEST: {
    primary: "text-(--node-test-text)",
    secondary: "text-(--node-test-text-secondary)",
  },
  CYCLE: {
    primary: "text-(--node-cycle-text)",
    secondary: "text-(--node-cycle-text-secondary)",
  },
} as const;

/**
 * {{camelCase kind}} Node Component
 *
 * Clean content-focused component with comprehensive data type handling:
 * • withNodeScaffold handles ALL structural styling
 * • Component focuses ONLY on content and layout
 * • Uses design system tokens for text colors
 * • Schema-driven controls available in Node Inspector
 * • Maintains enterprise validation and type safety
 * • Future-proof data propagation with comprehensive type handling
 */
const {{pascalCase kind}}NodeComponent = ({ data, id }: NodeProps) => {
  // Use proper React Flow data management
  const { nodeData, updateNodeData } = useNodeData(id, data);
  const { getNode, getNodes } = useReactFlow();



  // Get isExpanded directly from node data
  const isExpanded = (nodeData as {{pascalCase kind}}Data).isExpanded || false;

  // Update expanded state via node data
  const handleToggleExpanded = useCallback(() => {
    updateNodeData({ ...nodeData, isExpanded: !isExpanded });
  }, [nodeData, isExpanded, updateNodeData]);



  // Enterprise validation with comprehensive error handling
  const validationResult = validateNodeData(nodeData);
  const validatedData = validationResult.data;

  // Report validation errors for monitoring
  if (!validationResult.success) {
    reportValidationError('{{pascalCase kind}}', id, validationResult.errors, {
      originalData: validationResult.originalData,
      component: '{{pascalCase kind}}NodeComponent',
    });
  }

  // Enterprise data validation hook for real-time updates
  const { getHealthScore } = useNodeDataValidation(
    {{pascalCase kind}}DataSchema,
    '{{pascalCase kind}}',
    validatedData,
    id
  );

  // Get category-specific text colors
  const categoryKey = spec.category as keyof typeof CATEGORY_TEXT_COLORS;
  const categoryTextColors = CATEGORY_TEXT_COLORS[categoryKey] || CATEGORY_TEXT_COLORS.CREATE;

  // Comprehensive data type handler for future-proof data processing
  const processDataValue = (data: any): string => {
    // Handle primitive types
    if (data === null) {
      return 'null';
    } else if (data === undefined) {
      return 'undefined';
    } else if (typeof data === 'string') {
      return data || 'Empty string';
    } else if (typeof data === 'number') {
      return String(data);
    } else if (typeof data === 'boolean') {
      return data ? 'true' : 'false';
    } else if (typeof data === 'bigint') {
      return data.toString();
    } else if (typeof data === 'symbol') {
      return data.toString();
    } else if (typeof data === 'function') {
      return '[Function]';
    } else if (typeof data === 'object') {
      // Handle object types comprehensively
      if (Array.isArray(data)) {
        // Handle arrays
        if (data.length === 0) {
          return '[] (empty array)';
        } else {
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Array]';
          }
        }
      } else if (data instanceof Date) {
        // Handle Date objects
        return data.toISOString();
      } else if (data instanceof RegExp) {
        // Handle RegExp objects
        return data.toString();
      } else if (data instanceof Error) {
        // Handle Error objects
        return `Error: ${data.message}`;
      } else if (data instanceof Map) {
        // Handle Map objects
        try {
          return JSON.stringify(Array.from(data.entries()), null, 2);
        } catch {
          return '[Map]';
        }
      } else if (data instanceof Set) {
        // Handle Set objects
        try {
          return JSON.stringify(Array.from(data), null, 2);
        } catch {
          return '[Set]';
        }
      } else if (data instanceof Promise) {
        // Handle Promise objects
        return '[Promise]';
      } else {
        // Handle plain objects with common data patterns
        // Check for common data properties in order of preference
        const dataProperties = [
          'text', 'output', 'value', 'data', 'content', 'message', 
          'result', 'response', 'body', 'payload', 'input', 'output'
        ];
        
        for (const prop of dataProperties) {
          if (data[prop] !== null && data[prop] !== undefined) {
            if (typeof data[prop] === 'string') {
              return data[prop] || 'Empty string';
            } else if (typeof data[prop] === 'number') {
              return String(data[prop]);
            } else if (typeof data[prop] === 'boolean') {
              return data[prop] ? 'true' : 'false';
            } else if (typeof data[prop] === 'object') {
              try {
                return JSON.stringify(data[prop], null, 2);
              } catch {
                return `[${prop}]`;
              }
            } else {
              return String(data[prop]);
            }
          }
        }
        
        // If no common properties found, stringify the entire object
        try {
          return JSON.stringify(data, null, 2);
        } catch {
          return '[Object]';
        }
      }
    } else {
      // Fallback for any other types
      return String(data);
    }
  };



  {{#if (eq dataPropagation "input")}}
  // Modern data propagation logic - handles empty strings and immediate updates
  const nodes = useNodes();
  const edges = useEdges();
  const lastProcessedInputRef = useRef<string | null>(null);

  // Handle connection/disconnection events immediately
  useEffect(() => {
    const handleConnectionChange = () => {
      const inputEdges = edges.filter(edge => edge.target === id);
      const inputNodes = inputEdges.map(edge => 
        nodes.find(node => node.id === edge.source)
      ).filter(Boolean);
      
      if (inputNodes.length === 0) {
        // No more connections - clear the data
        lastProcessedInputRef.current = null;
        updateNodeData({
          isActive: false,
          receivedData: 'No connected inputs',
          text: 'No connected inputs',
          output: 'No connected inputs'
        });
      }
    };

    handleConnectionChange();
  }, [updateNodeData, id, getNodes, getEdges]);

  // Direct data access to avoid timing issues
  useEffect(() => {
    const nodes = getNodes();
    const edges = getEdges();
    
    // Find connected input nodes
    const inputEdges = edges.filter(edge => edge.target === id);
    const inputNodes = inputEdges.map(edge => 
      nodes.find(node => node.id === edge.source)
    ).filter(Boolean);
    
    if (inputNodes.length > 0) {
      // Collect text from all connected input nodes
      const allTexts: string[] = [];
      
      inputNodes.forEach(sourceNode => {
        if (sourceNode?.data) {
          let nodeText = '';
          
          if (sourceNode.data.text !== undefined) {
            nodeText = String(sourceNode.data.text);
          } else if (sourceNode.data.output !== undefined) {
            nodeText = String(sourceNode.data.output);
          } else {
            nodeText = String(sourceNode.data);
          }
          
          // Only add valid text
          if (nodeText && nodeText !== 'null' && nodeText !== 'undefined') {
            allTexts.push(nodeText);
          }
        }
      });
      
      // Concatenate all texts without separator for predictable behavior
      const concatenatedText = allTexts.join('');
      
      // Always update if the text has changed (including empty strings)
      if (lastProcessedInputRef.current !== concatenatedText) {
        lastProcessedInputRef.current = concatenatedText;
        
        const hasContent = concatenatedText && concatenatedText.trim().length > 0;
        
        updateNodeData({ 
          isActive: hasContent,
          receivedData: concatenatedText,
          text: concatenatedText,
          output: concatenatedText
        });
      }
    } else {
      // No connected inputs - clear the data
      if (lastProcessedInputRef.current !== null) {
        lastProcessedInputRef.current = null;
        
        updateNodeData({ 
          isActive: false,
          receivedData: 'No connected inputs',
          text: 'No connected inputs',
          output: 'No connected inputs'
        });
      }
    }
  }, [id, getNodes, getEdges, updateNodeData]);
  {{/if}}

  {{#if (eq dataPropagation "both")}}
  // Modern data propagation logic - handles empty strings and immediate updates
  const nodes = useNodes();
  const edges = useEdges();
  const lastProcessedInputRef = useRef<string | null>(null);

  // Handle connection/disconnection events immediately
  useEffect(() => {
    const handleConnectionChange = () => {
      const inputEdges = edges.filter(edge => edge.target === id);
      const inputNodes = inputEdges.map(edge => 
        nodes.find(node => node.id === edge.source)
      ).filter(Boolean);
      
      if (inputNodes.length === 0) {
        // No more connections - clear the data
        lastProcessedInputRef.current = null;
        updateNodeData({
          isActive: false,
          receivedData: 'No connected inputs',
          text: 'No connected inputs',
          output: 'No connected inputs'
        });
      }
    };

    handleConnectionChange();
  }, [updateNodeData, id, getNodes, getEdges]);

  // Direct data access to avoid timing issues
  useEffect(() => {
    const nodes = getNodes();
    const edges = getEdges();
    
    // Find connected input nodes
    const inputEdges = edges.filter(edge => edge.target === id);
    const inputNodes = inputEdges.map(edge => 
      nodes.find(node => node.id === edge.source)
    ).filter(Boolean);
    
    if (inputNodes.length > 0) {
      // Collect text from all connected input nodes
      const allTexts: string[] = [];
      
      inputNodes.forEach(sourceNode => {
        if (sourceNode?.data) {
          let nodeText = '';
          
          if (sourceNode.data.text !== undefined) {
            nodeText = String(sourceNode.data.text);
          } else if (sourceNode.data.output !== undefined) {
            nodeText = String(sourceNode.data.output);
          } else {
            nodeText = String(sourceNode.data);
          }
          
          // Only add valid text
          if (nodeText && nodeText !== 'null' && nodeText !== 'undefined') {
            allTexts.push(nodeText);
          }
        }
      });
      
      // Concatenate all texts without separator for predictable behavior
      const concatenatedText = allTexts.join('');
      
      // Always update if the text has changed (including empty strings)
      if (lastProcessedInputRef.current !== concatenatedText) {
        lastProcessedInputRef.current = concatenatedText;
        
        const hasContent = concatenatedText && concatenatedText.trim().length > 0;
        
        updateNodeData({ 
          isActive: hasContent,
          receivedData: concatenatedText,
          text: concatenatedText,
          output: concatenatedText
        });
      }
    } else {
      // No connected inputs - clear the data
      if (lastProcessedInputRef.current !== null) {
        lastProcessedInputRef.current = null;
        
        updateNodeData({ 
          isActive: false,
          receivedData: 'No connected inputs',
          text: 'No connected inputs',
          output: 'No connected inputs'
        });
      }
    }
  }, [id, getNodes, getEdges, updateNodeData]);
  {{/if}}

  return (
    <>
      <ExpandCollapseButton showUI={isExpanded} onToggle={handleToggleExpanded} size="sm" />

      {isExpanded ? (
        <div className={CONTENT_STYLES.content.expanded}>
          {{#if (eq dataPropagation "input")}}
          {/* Display received data from connected nodes (input-only mode) */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className="font-normal text-xs">
                {validatedData.text || 'No connected inputs'}
              </div>
            </div>
          </div>
          {{/if}}

          {{#if (eq dataPropagation "both")}}
          {/* Display received data from connected nodes (full data flow mode) */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className="font-normal text-xs">
                {validatedData.text || 'No connected inputs'}
              </div>
            </div>
          </div>
          {{/if}}

          {{#if (eq dataPropagation "output")}}
          {/* Display node-specific UI for output-only mode */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className={`text-xs font-medium ${categoryTextColors.primary} uppercase tracking-wide mb-1`}>
                {{titleCase kind}}
              </div>
              <div className={`text-xs ${categoryTextColors.secondary}`}>
                {validatedData.isEnabled ? validatedData.text : 'Disabled'}
              </div>
            </div>
          </div>
          {{/if}}

          {{#if (eq dataPropagation "none")}}
          {/* Display node-specific UI for standalone mode */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className={`text-xs font-medium ${categoryTextColors.primary} uppercase tracking-wide mb-1`}>
                {{titleCase kind}}
              </div>
              <div className={`text-xs ${categoryTextColors.secondary}`}>
                {validatedData.isEnabled ? validatedData.text : 'Disabled'}
              </div>
            </div>
          </div>
          {{/if}}
        </div>
      ) : (
        <div className={CONTENT_STYLES.content.collapsed}>
          <div className="text-center">
            {{#if (eq dataPropagation "input")}}
            {spec.receivedData?.showInCollapsed && validatedData.text !== 'No connected inputs' ? (
              <div className={`text-xs ${categoryTextColors.primary} tracking-wide truncate w-[50px]`}>
                {validatedData.text}
              </div>
            ) : (
              <div className={`text-xs font-medium ${categoryTextColors.primary} tracking-wide truncate w-[50px]`}>
                {{upper (truncate kind 4)}}
              </div>
            )}
            {{/if}}
            {{#if (eq dataPropagation "both")}}
            {spec.receivedData?.showInCollapsed && validatedData.text !== 'No connected inputs' ? (
              <div className={`text-xs ${categoryTextColors.primary} tracking-wide truncate w-[50px]`}>
                {validatedData.text}
              </div>
            ) : (
              <div className={`text-xs font-medium ${categoryTextColors.primary} tracking-wide truncate w-[50px]`}>
                {{upper (truncate kind 4)}}
              </div>
            )}
            {{/if}}
            {{#if (eq dataPropagation "output")}}
            <div className={`text-xs font-medium ${categoryTextColors.primary} tracking-wide truncate w-[50px]`}>
              {{upper (truncate kind 4)}}
            </div>
            {{/if}}
            {{#if (eq dataPropagation "none")}}
            <div className={`text-xs font-medium ${categoryTextColors.primary} tracking-wide truncate w-[50px]`}>
              {{upper (truncate kind 4)}}
            </div>
            {{/if}}
          </div>
        </div>
      )}
    </>
  );
};

export default withNodeScaffold(spec, {{pascalCase kind}}NodeComponent);

// Export spec for registry access
export { spec };
