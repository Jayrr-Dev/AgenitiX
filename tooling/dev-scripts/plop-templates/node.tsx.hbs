/**
 * {{titleCase kind}} NODE - Clean content-focused node template
 *
 * • Focuses ONLY on content and layout - no structural styling
 * • withNodeScaffold handles all borders, sizing, theming, interactive states
 * • Schema-driven controls in Node Inspector
 * • Type-safe data validation with Zod schema
 * • Clean separation of concerns for maximum maintainability
 * • Comprehensive data type handling for future-proof data flow
 *
 * Keywords: {{kebabCase kind}}, content-focused, schema-driven, type-safe, clean-architecture, data-propagation
 */

import React, { useCallback, useEffect, useState, useRef } from 'react';
import { NodeProps, useReactFlow, useNodes, useEdges } from '@xyflow/react';
import { z } from 'zod';
import { withNodeScaffold } from '@/features/business-logic-modern/infrastructure/node-core/withNodeScaffold';
import { NodeSpec } from '@/features/business-logic-modern/infrastructure/node-core/NodeSpec';
import {
  createNodeValidator,
  CommonSchemas,
  reportValidationError,
  useNodeDataValidation
} from '@/features/business-logic-modern/infrastructure/node-core/validation';
import { SafeSchemas, createSafeInitialData } from '@/features/business-logic-modern/infrastructure/node-core/schema-helpers';
import { CATEGORIES } from '@/features/business-logic-modern/infrastructure/theming/categories';
import { EXPANDED_SIZES, COLLAPSED_SIZES } from '@/features/business-logic-modern/infrastructure/theming/sizing';
import { ExpandCollapseButton } from '@/components/nodes/ExpandCollapseButton';
import { useNodeData } from '@/hooks/useNodeData';

// -- PLOP-INJECTED-IMPORTS --

/**
 * Data schema for {{titleCase kind}} node
 * Define your node's data structure - controls are automatically generated
 */
const {{pascalCase kind}}DataSchema = z.object({
  // Basic fields - customize as needed
  text: SafeSchemas.text('Default text'),
  isEnabled: SafeSchemas.boolean(true),
  isActive: SafeSchemas.boolean(false),
  isExpanded: SafeSchemas.boolean(false),
  {{#if (eq dataPropagation "input")}}
  receivedData: SafeSchemas.optionalText(), // Store received data from connected nodes
  {{/if}}
  {{#if (eq dataPropagation "both")}}
  receivedData: SafeSchemas.optionalText(), // Store received data from connected nodes
  {{/if}}

  // Add your fields here - controls are auto-generated:
  // description: SafeSchemas.optionalText(),
  // count: SafeSchemas.number(1, 1, 100),
  // priority: SafeSchemas.enum(['low', 'medium', 'high'], 'medium'),
}).passthrough();

type {{pascalCase kind}}Data = z.infer<typeof {{pascalCase kind}}DataSchema>;

// Create enterprise validator
const validateNodeData = createNodeValidator({{pascalCase kind}}DataSchema, '{{pascalCase kind}}');

/**
 * Node specification with schema-driven controls
 */
const spec: NodeSpec = {
  kind: '{{camelCase kind}}',
  displayName: '{{camelCase kind}}'.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim(),
  label: '{{camelCase kind}}'.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim(),
  category: CATEGORIES.{{constantCase category}},
  size: {
    expanded: {{expandedSizeConstant expandedSize}},
    collapsed: {{collapsedSizeConstant collapsedSize}},
  },
  handles: [
    { id: 'json-input', code: 'j', position: 'top', type: 'target', dataType: 'JSON' },
    { id: 'output', code: 's', position: 'right', type: 'source', dataType: 'String' },
    { id: 'activate', code: 'b', position: 'left', type: 'target', dataType: 'Boolean' },
  ],
  inspector: {
    key: '{{pascalCase kind}}Inspector',
  },
  version: 1,
  runtime: {
    execute: '{{camelCase kind}}_execute_v1',
  },
  initialData: createSafeInitialData({{pascalCase kind}}DataSchema),
  dataSchema: {{pascalCase kind}}DataSchema,
  controls: {
    autoGenerate: true,
    excludeFields: ["isActive", "receivedData"], // Hide system fields from controls
    customFields: [
      {
        key: "isExpanded",
        type: "boolean",
        label: "Expand",
      },
    ],
  },
  icon: '{{icon}}' || 'LuCircle', // Placeholder - update with appropriate Lucide icon
  author: '{{author}}',
  description: '{{description}}',
  feature: '{{feature}}',
  {{#if customTheming}}
  theming: {
    {{#if bgDark}}bgDark: '{{bgDark}}',{{/if}}
    {{#if borderDark}}borderDark: '{{borderDark}}',{{/if}}
    {{#if textDark}}textDark: '{{textDark}}',{{/if}}
  },
  {{/if}}
  {{#if (eq dataPropagation "input")}}
  receivedData: {
    enabled: true,
    displayMode: 'formatted',
    showInCollapsed: true,
    formatData: (data: any) => {
      // Comprehensive data type handling
      if (data === null) return 'null';
      if (data === undefined) return 'undefined';
      if (typeof data === 'string') return data || 'Empty string';
      if (typeof data === 'number') return String(data);
      if (typeof data === 'boolean') return data ? 'true' : 'false';
      if (typeof data === 'bigint') return data.toString();
      if (typeof data === 'symbol') return data.toString();
      if (typeof data === 'function') return '[Function]';
      
      if (typeof data === 'object') {
        if (Array.isArray(data)) {
          if (data.length === 0) return '[] (empty array)';
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Array]';
          }
        } else if (data instanceof Date) {
          return data.toISOString();
        } else if (data instanceof RegExp) {
          return data.toString();
        } else if (data instanceof Error) {
          return `Error: ${data.message}`;
        } else if (data instanceof Map) {
          try {
            return JSON.stringify(Array.from(data.entries()), null, 2);
          } catch {
            return '[Map]';
          }
        } else if (data instanceof Set) {
          try {
            return JSON.stringify(Array.from(data), null, 2);
          } catch {
            return '[Set]';
          }
        } else if (data instanceof Promise) {
          return '[Promise]';
        } else {
          // Handle plain objects with common data properties
          const dataProperties = [
            'text', 'output', 'value', 'data', 'content', 'message', 
            'result', 'response', 'body', 'payload', 'input', 'output'
          ];
          
          for (const prop of dataProperties) {
            if (data[prop] !== null && data[prop] !== undefined) {
              if (typeof data[prop] === 'string') {
                return data[prop] || 'Empty string';
              } else if (typeof data[prop] === 'number') {
                return String(data[prop]);
              } else if (typeof data[prop] === 'boolean') {
                return data[prop] ? 'true' : 'false';
              } else if (typeof data[prop] === 'object') {
                try {
                  return JSON.stringify(data[prop], null, 2);
                } catch {
                  return `[${prop}]`;
                }
              } else {
                return String(data[prop]);
              }
            }
          }
          
          // If no common properties found, stringify the entire object
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Object]';
          }
        }
      }
      
      // Fallback for any other types
      return String(data);
    },
  },
  {{/if}}
  {{#if (eq dataPropagation "both")}}
  receivedData: {
    enabled: true,
    displayMode: 'formatted',
    showInCollapsed: true,
    formatData: (data: any) => {
      // Comprehensive data type handling
      if (data === null) return 'null';
      if (data === undefined) return 'undefined';
      if (typeof data === 'string') return data || 'Empty string';
      if (typeof data === 'number') return String(data);
      if (typeof data === 'boolean') return data ? 'true' : 'false';
      if (typeof data === 'bigint') return data.toString();
      if (typeof data === 'symbol') return data.toString();
      if (typeof data === 'function') return '[Function]';
      
      if (typeof data === 'object') {
        if (Array.isArray(data)) {
          if (data.length === 0) return '[] (empty array)';
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Array]';
          }
        } else if (data instanceof Date) {
          return data.toISOString();
        } else if (data instanceof RegExp) {
          return data.toString();
        } else if (data instanceof Set) {
          try {
            return JSON.stringify(Array.from(data), null, 2);
          } catch {
            return '[Set]';
          }
        } else if (data instanceof Promise) {
          return '[Promise]';
        } else {
          // Handle plain objects with common data properties
          const dataProperties = [
            'text', 'output', 'value', 'data', 'content', 'message', 
            'result', 'response', 'body', 'payload', 'input', 'output'
          ];
          
          for (const prop of dataProperties) {
            if (data[prop] !== null && data[prop] !== undefined) {
              if (typeof data[prop] === 'string') {
                return data[prop] || 'Empty string';
              } else if (typeof data[prop] === 'number') {
                return String(data[prop]);
              } else if (typeof data[prop] === 'boolean') {
                return data[prop] ? 'true' : 'false';
              } else if (typeof data[prop] === 'object') {
                try {
                  return JSON.stringify(data[prop], null, 2);
                } catch {
                  return `[${prop}]`;
                }
              } else {
                return String(data[prop]);
              }
            }
          }
          
          // If no common properties found, stringify the entire object
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Object]';
          }
        }
      }
      
      // Fallback for any other types
      return String(data);
    },
  },
  {{/if}}
};

/**
 * Content-focused styling constants
 * Only handles internal layout and content - no structural styling
 */
const CONTENT_STYLES = {
  // Content area layouts
  content: {
    expanded: "p-4 w-full h-full flex flex-col",
    collapsed: "flex items-center justify-center w-full h-full",
  },

  // Header layouts
  header: {
    container: "flex items-center justify-between mb-3",
  },

  // Main content layouts
  main: {
    container: "flex-1 flex items-center justify-center",
    content: "text-center",
    icon: "text-2xl mb-2",
  },

  // Collapsed state layouts
  collapsed: {
    icon: "text-2xl",
  },
} as const;

/**
 * Category-specific text colors from design system
 */
const CATEGORY_TEXT_COLORS = {
  CREATE: {
    primary: "text-(--node-create-text)",
    secondary: "text-(--node-create-text-secondary)",
  },
  VIEW: {
    primary: "text-(--node-view-text)",
    secondary: "text-(--node-view-text-secondary)",
  },
  TRIGGER: {
    primary: "text-(--node-trigger-text)",
    secondary: "text-(--node-trigger-text-secondary)",
  },
  TEST: {
    primary: "text-(--node-test-text)",
    secondary: "text-(--node-test-text-secondary)",
  },
  CYCLE: {
    primary: "text-(--node-cycle-text)",
    secondary: "text-(--node-cycle-text-secondary)",
  },
} as const;

/**
 * {{camelCase kind}} Node Component
 *
 * Clean content-focused component with comprehensive data type handling:
 * • withNodeScaffold handles ALL structural styling
 * • Component focuses ONLY on content and layout
 * • Uses design system tokens for text colors
 * • Schema-driven controls available in Node Inspector
 * • Maintains enterprise validation and type safety
 * • Future-proof data propagation with comprehensive type handling
 */
const {{pascalCase kind}}NodeComponent = ({ data, id }: NodeProps) => {
  // Use proper React Flow data management
  const { nodeData, updateNodeData } = useNodeData(id, data);
  const { getNode, getNodes } = useReactFlow();

  // Local state for received data
  const [receivedData, setReceivedData] = useState<string>('');

  // Get isExpanded directly from node data
  const isExpanded = (nodeData as {{pascalCase kind}}Data).isExpanded || false;

  // Update expanded state via node data
  const handleToggleExpanded = useCallback(() => {
    updateNodeData({ ...nodeData, isExpanded: !isExpanded });
  }, [nodeData, isExpanded, updateNodeData]);

  {{#if (eq dataPropagation "input")}}
  // Ref to track if we've already updated node data to prevent infinite loops
  const lastUpdateRef = useRef<{ text: string; active: boolean } | null>(null);
  {{/if}}
  {{#if (eq dataPropagation "both")}}
  // Ref to track if we've already updated node data to prevent infinite loops
  const lastUpdateRef = useRef<{ text: string; active: boolean } | null>(null);
  {{/if}}

  // Enterprise validation with comprehensive error handling
  const validationResult = validateNodeData(nodeData);
  const validatedData = validationResult.data;

  // Report validation errors for monitoring
  if (!validationResult.success) {
    reportValidationError('{{pascalCase kind}}', id, validationResult.errors, {
      originalData: validationResult.originalData,
      component: '{{pascalCase kind}}NodeComponent',
    });
  }

  // Enterprise data validation hook for real-time updates
  const { getHealthScore } = useNodeDataValidation(
    {{pascalCase kind}}DataSchema,
    '{{pascalCase kind}}',
    validatedData,
    id
  );

  // Get category-specific text colors
  const categoryKey = spec.category as keyof typeof CATEGORY_TEXT_COLORS;
  const categoryTextColors = CATEGORY_TEXT_COLORS[categoryKey] || CATEGORY_TEXT_COLORS.CREATE;

  // Comprehensive data type handler for future-proof data processing
  const processDataValue = (data: any): string => {
    // Handle primitive types
    if (data === null) {
      return 'null';
    } else if (data === undefined) {
      return 'undefined';
    } else if (typeof data === 'string') {
      return data || 'Empty string';
    } else if (typeof data === 'number') {
      return String(data);
    } else if (typeof data === 'boolean') {
      return data ? 'true' : 'false';
    } else if (typeof data === 'bigint') {
      return data.toString();
    } else if (typeof data === 'symbol') {
      return data.toString();
    } else if (typeof data === 'function') {
      return '[Function]';
    } else if (typeof data === 'object') {
      // Handle object types comprehensively
      if (Array.isArray(data)) {
        // Handle arrays
        if (data.length === 0) {
          return '[] (empty array)';
        } else {
          try {
            return JSON.stringify(data, null, 2);
          } catch {
            return '[Array]';
          }
        }
      } else if (data instanceof Date) {
        // Handle Date objects
        return data.toISOString();
      } else if (data instanceof RegExp) {
        // Handle RegExp objects
        return data.toString();
      } else if (data instanceof Error) {
        // Handle Error objects
        return `Error: ${data.message}`;
      } else if (data instanceof Map) {
        // Handle Map objects
        try {
          return JSON.stringify(Array.from(data.entries()), null, 2);
        } catch {
          return '[Map]';
        }
      } else if (data instanceof Set) {
        // Handle Set objects
        try {
          return JSON.stringify(Array.from(data), null, 2);
        } catch {
          return '[Set]';
        }
      } else if (data instanceof Promise) {
        // Handle Promise objects
        return '[Promise]';
      } else {
        // Handle plain objects with common data patterns
        // Check for common data properties in order of preference
        const dataProperties = [
          'text', 'output', 'value', 'data', 'content', 'message', 
          'result', 'response', 'body', 'payload', 'input', 'output'
        ];
        
        for (const prop of dataProperties) {
          if (data[prop] !== null && data[prop] !== undefined) {
            if (typeof data[prop] === 'string') {
              return data[prop] || 'Empty string';
            } else if (typeof data[prop] === 'number') {
              return String(data[prop]);
            } else if (typeof data[prop] === 'boolean') {
              return data[prop] ? 'true' : 'false';
            } else if (typeof data[prop] === 'object') {
              try {
                return JSON.stringify(data[prop], null, 2);
              } catch {
                return `[${prop}]`;
              }
            } else {
              return String(data[prop]);
            }
          }
        }
        
        // If no common properties found, stringify the entire object
        try {
          return JSON.stringify(data, null, 2);
        } catch {
          return '[Object]';
        }
      }
    } else {
      // Fallback for any other types
      return String(data);
    }
  };

  {{#if (eq dataPropagation "input")}}
  // Get all nodes and edges to find connections (input-only mode)
  const nodes = useNodes();
  const edges = useEdges();

  // Process connected data when nodes or edges change
  useEffect(() => {
    const processConnectedData = () => {
      try {
        const connectedTexts: string[] = [];
        
        // Find edges that connect to this node
        const incomingEdges = edges.filter(edge => edge.target === id);
        
        // Get data from source nodes using comprehensive type handler
        incomingEdges.forEach(edge => {
          const sourceNode = nodes.find(node => node.id === edge.source);
          if (sourceNode && sourceNode.data) {
            const textValue = processDataValue(sourceNode.data);
            connectedTexts.push(textValue);
          }
        });

        // Update received data with proper null handling and determine active state
        if (connectedTexts.length > 0) {
          const formattedTexts = connectedTexts.map(text => {
            if (text === 'null') {
              return 'null';
            } else if (text === 'undefined') {
              return 'undefined';
            } else if (text === 'Empty string') {
              return '';
            } else if (text === 'Invalid data') {
              return 'Invalid data';
            } else {
              return text;
            }
          });
          
          const finalText = formattedTexts.join('\n');
          setReceivedData(finalText);
          
          // Determine if node should be active based on received data
          const hasValidData = formattedTexts.some(text => 
            text !== 'null' && 
            text !== 'undefined' && 
            text !== '' && 
            text !== 'Invalid data' &&
            text !== 'No connected inputs'
          );
          
          // Only update node data if values have actually changed to prevent infinite loops
          const currentUpdate = { text: finalText, active: hasValidData };
          if (!lastUpdateRef.current || 
              lastUpdateRef.current.text !== currentUpdate.text || 
              lastUpdateRef.current.active !== currentUpdate.active) {
            lastUpdateRef.current = currentUpdate;
            updateNodeData({ 
              ...nodeData, 
              isActive: hasValidData,
              receivedData: finalText,
              text: finalText // Also update the text field for inspector display
            });
          }
        } else {
          setReceivedData('');
          
          // Only update node data if values have actually changed
          const currentUpdate = { text: '', active: false };
          if (!lastUpdateRef.current || 
              lastUpdateRef.current.text !== currentUpdate.text || 
              lastUpdateRef.current.active !== currentUpdate.active) {
            lastUpdateRef.current = currentUpdate;
            updateNodeData({ 
              ...nodeData, 
              isActive: false,
              receivedData: '',
              text: 'No connected inputs' // Update text field for inspector display
            });
          }
        }
      } catch (error) {
        console.error('Error processing connected data:', error);
        setReceivedData('Error processing inputs');
      }
    };

    processConnectedData();
  }, [nodes, edges, id]);
  {{/if}}

  {{#if (eq dataPropagation "both")}}
  // Get all nodes and edges to find connections (full data flow mode)
  const nodes = useNodes();
  const edges = useEdges();

  // Process connected data when nodes or edges change
  useEffect(() => {
    const processConnectedData = () => {
      try {
        const connectedTexts: string[] = [];
        
        // Find edges that connect to this node
        const incomingEdges = edges.filter(edge => edge.target === id);
        
        // Get data from source nodes using comprehensive type handler
        incomingEdges.forEach(edge => {
          const sourceNode = nodes.find(node => node.id === edge.source);
          if (sourceNode && sourceNode.data) {
            const textValue = processDataValue(sourceNode.data);
            connectedTexts.push(textValue);
          }
        });

        // Update received data with proper null handling and determine active state (both mode)
        if (connectedTexts.length > 0) {
          const formattedTexts = connectedTexts.map(text => {
            if (text === 'null') {
              return 'null';
            } else if (text === 'undefined') {
              return 'undefined';
            } else if (text === 'Empty string') {
              return '';
            } else if (text === 'Invalid data') {
              return 'Invalid data';
            } else {
              return text;
            }
          });
          
          const finalText = formattedTexts.join('\n');
          setReceivedData(finalText);
          
          // Determine if node should be active based on received data
          const hasValidData = formattedTexts.some(text => 
            text !== 'null' && 
            text !== 'undefined' && 
            text !== '' && 
            text !== 'Invalid data' &&
            text !== 'No connected inputs'
          );
          
          // Only update node data if values have actually changed to prevent infinite loops
          const currentUpdate = { text: finalText, active: hasValidData };
          if (!lastUpdateRef.current || 
              lastUpdateRef.current.text !== currentUpdate.text || 
              lastUpdateRef.current.active !== currentUpdate.active) {
            lastUpdateRef.current = currentUpdate;
            updateNodeData({ 
              ...nodeData, 
              isActive: hasValidData,
              receivedData: finalText,
              text: finalText // Also update the text field for inspector display
            });
          }
        } else {
          setReceivedData('');
          
          // Only update node data if values have actually changed
          const currentUpdate = { text: '', active: false };
          if (!lastUpdateRef.current || 
              lastUpdateRef.current.text !== currentUpdate.text || 
              lastUpdateRef.current.active !== currentUpdate.active) {
            lastUpdateRef.current = currentUpdate;
            updateNodeData({ 
              ...nodeData, 
              isActive: false,
              receivedData: '',
              text: 'No connected inputs' // Update text field for inspector display
            });
          }
        }
      } catch (error) {
        console.error('Error processing connected data:', error);
        setReceivedData('Error processing inputs');
      }
    };

    processConnectedData();
  }, [nodes, edges, id]);
  {{/if}}

  return (
    <>
      <ExpandCollapseButton showUI={isExpanded} onToggle={handleToggleExpanded} size="sm" />

      {isExpanded ? (
        <div className={CONTENT_STYLES.content.expanded}>
          {{#if (eq dataPropagation "input")}}
          {/* Display received data from connected nodes (input-only mode) */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className={`text-sm ${categoryTextColors.primary} break-words p-2 bg-gray-50 dark:bg-gray-800 rounded`}>
                <div className="text-xs text-gray-500 dark:text-gray-400 mb-1">
                  Received Data:
                </div>
                <div className="font-medium">
                  {validatedData.text || receivedData || 'No connected inputs'}
                </div>
              </div>
            </div>
          </div>
          {{/if}}

          {{#if (eq dataPropagation "both")}}
          {/* Display received data from connected nodes (full data flow mode) */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className={`text-sm ${categoryTextColors.primary} break-words p-2 bg-gray-50 dark:bg-gray-800 rounded`}>
                <div className="text-xs text-gray-500 dark:text-gray-400 mb-1">
                  Received Data:
                </div>
                <div className="font-medium">
                  {validatedData.text || receivedData || 'No connected inputs'}
                </div>
              </div>
            </div>
          </div>
          {{/if}}

          {{#if (eq dataPropagation "output")}}
          {/* Display node-specific UI for output-only mode */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className={`text-xs font-medium ${categoryTextColors.primary} uppercase tracking-wide mb-1`}>
                {{titleCase kind}}
              </div>
              <div className={`text-xs ${categoryTextColors.secondary}`}>
                {validatedData.isEnabled ? validatedData.text : 'Disabled'}
              </div>
            </div>
          </div>
          {{/if}}

          {{#if (eq dataPropagation "none")}}
          {/* Display node-specific UI for standalone mode */}
          <div className={CONTENT_STYLES.main.container}>
            <div className={CONTENT_STYLES.main.content}>
              <div className={`text-xs font-medium ${categoryTextColors.primary} uppercase tracking-wide mb-1`}>
                {{titleCase kind}}
              </div>
              <div className={`text-xs ${categoryTextColors.secondary}`}>
                {validatedData.isEnabled ? validatedData.text : 'Disabled'}
              </div>
            </div>
          </div>
          {{/if}}
        </div>
      ) : (
        <div className={CONTENT_STYLES.content.collapsed}>
          <div className="text-center">
            <div className={`text-xs font-medium ${categoryTextColors.primary} uppercase tracking-wide`}>
              {{upper (truncate kind 4)}}
            </div>
          </div>
        </div>
      )}
    </>
  );
};

export default withNodeScaffold(spec, {{pascalCase kind}}NodeComponent);

// Export spec for registry access
export { spec };
