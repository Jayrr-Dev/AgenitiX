---
description: 
globs: features/business-logic/**/*,features/business-logic/*
alwaysApply: false
---
# Business Logic Development Context

## 🤖 AI Assistant Instructions

You are working in the business logic layer of a visual flow editor built with React Flow. This system has been **completely refactored** from monolithic files into a **modular architecture**. 

**CRITICAL**: The old monolithic approach is obsolete. Always use the new modular patterns described below.

### Key Points for AI Understanding:
- **Never modify large monolithic files** - they've been broken down into focused modules
- **Always follow the 6-step node creation process** - missing any step will break functionality
- **Use the established patterns** - don't reinvent existing solutions
- **Maintain type safety** - TypeScript is strictly enforced throughout
- **Follow the modular structure** - each file has a single responsibility

## 🏗️ Architecture Overview

The business logic layer has been refactored from monolithic files (748+ lines) into a modular architecture with clear separation of concerns:

```
features/business-logic/
├── flow-editor/                    # Main flow editor (refactored from 748 lines → modular)
│   ├── FlowEditor.tsx             # Main orchestrator component (216 lines)
│   ├── types/index.ts             # Type definitions (195 lines)
│   ├── constants/index.ts         # Configuration constants (188 lines)
│   ├── hooks/                     # Custom hooks for state management
│   │   ├── useFlowEditorState.ts  # Main state management (212 lines)
│   │   ├── useReactFlowHandlers.ts # ReactFlow event handlers (147 lines)
│   │   ├── useDragAndDrop.ts      # Drag & drop functionality (58 lines)
│   │   └── useKeyboardShortcuts.ts # Keyboard shortcuts (45 lines)
│   ├── components/
│   │   └── FlowCanvas.tsx         # ReactFlow canvas component (199 lines)
│   └── utils/                     # Utility functions
│       ├── nodeFactory.ts         # Node creation utilities (66 lines)
│       ├── outputUtils.ts         # Output computation utilities (83 lines)
│       └── connectionUtils.ts     # Connection validation utilities (60 lines)
├── components/
│   ├── sidebar/                   # Sidebar component (refactored from 448 lines → modular)
│   │   ├── SidebarTabs.tsx       # Main tabbed interface
│   │   ├── types.ts              # Type definitions and tab configurations
│   │   ├── constants.ts          # Default stencils and variant configurations
│   │   └── hooks/                # Custom hooks
│   └── node-inspector/           # Node inspector (refactored from 1,196 lines → modular)
│       ├── NodeInspector.tsx     # Main orchestrator (~100 lines vs 1,196)
│       ├── types.ts              # Type definitions
│       ├── constants.ts          # Node type configurations
│       └── components/           # Focused UI components
└── nodes/                        # Node implementations
    └── main/                     # Core logic nodes
```

## 🎯 Key Architecture Patterns

### Node Structure Requirements:
- **ICON state**: 60x60px (default collapsed state)
- **EXPANDED state**: 120x120px (when showUI is true)
- **Text-based nodes**: 120x60px in ICON state
- **Toggle button**: `{showUI ? '⦿' : '⦾'}` controls expansion
- **Default state**: ICON (collapsed)

### Handle Types & Colors:
- `s` = string (blue #3b82f6)
- `n` = number (orange #f59e42)  
- `b` = boolean (green #10b981)
- `j` = JSON (indigo #6366f1)
- `a` = array (pink #f472b6)
- `N` = Bigint (purple #a21caf)
- `f` = float (yellow #fbbf24)
- `x` = any (gray #6b7280)
- `u` = undefined (light gray #d1d5db)
- `S` = symbol (gold #eab308)
- `∅` = null (red #ef4444)

## 🚀 Creating New Nodes - MANDATORY Process

**IMPORTANT FOR AI**: When creating nodes, you MUST follow this exact 6-step process. Missing any step will result in broken functionality.

The node creation process has been streamlined with the new modular architecture. **Reference the detailed guide at `creating-new-nodes.md` for complete examples.**

### 🔴 CRITICAL: 6-Step Checklist (ALL REQUIRED)

1. ✅ **Create node component** in `nodes/main/YourNodeName.tsx`
2. ✅ **Add type definitions** in `flow-editor/types/index.ts` 
3. ✅ **Register configuration** in `flow-editor/constants/index.ts`
4. ✅ **Register in FlowCanvas** in `flow-editor/components/FlowCanvas.tsx`
5. ✅ **Add to sidebar** in `components/sidebar/constants.ts`
6. ✅ **Add controls** in `components/node-inspector/components/NodeControls.tsx`

**Missing ANY step = Broken node that won't work!**

### Quick Implementation Guide

**For complete code examples and detailed instructions, see `creating-new-nodes.md`**

#### Step 1: Node Component (`nodes/main/YourNodeName.tsx`)
```typescript
// Must include: useState for showUI, useEffect for logic, proper handles
// Required pattern: 60x60px icon state, 120x120px expanded state
// Toggle button: {showUI ? '⦿' : '⦾'}
```

#### Step 2: Type Definitions (`flow-editor/types/index.ts`)
```typescript
// Add interface for your node data
// Add to AgenNode union type - CRITICAL for type safety
```

#### Step 3: Configuration (`flow-editor/constants/index.ts`)
```typescript
// Add to NODE_TYPE_CONFIG with defaultData
// Must match your interface exactly
```

#### Step 4: Registration (`flow-editor/components/FlowCanvas.tsx`)
```typescript
// Import your node component
// Add to nodeTypes useMemo object
```

#### Step 5: Sidebar (`components/sidebar/constants.ts`)
```typescript
// Add stencil to appropriate category in DEFAULT_STENCILS_A
// Include id, nodeType, label, description
```

#### Step 6: Controls (`components/node-inspector/components/NodeControls.tsx`)
```typescript
// Add case to switch statement
// Create control component if needed
```

## 📁 Node Categories

Organize nodes by business function:

- **main**: Core logic nodes (triggers, converters, logic gates)
- **marketing**: Marketing-specific nodes (campaigns, analytics)
- **sales**: Sales workflow nodes (leads, opportunities)
- **operations**: Operational task nodes (workflows, automation)
- **strategy**: Strategic planning nodes (goals, initiatives)
- **finance**: Financial/budget nodes (costs, revenue)
- **people**: HR/talent nodes (employees, skills)

## 🔧 Required Patterns & Utilities

**AI MUST USE**: These are the established patterns. Don't create alternatives.

### State Management (REQUIRED):
```typescript
// ALWAYS use useReactFlow for node updates
const { updateNodeData } = useReactFlow();

// Update node data (standard pattern)
updateNodeData(id, { property: newValue });
```

### Input Handling (REQUIRED):
```typescript
// ALWAYS use these hooks for input processing
const connections = useNodeConnections();
const nodesData = useNodesData();

// Get single input value (utility function)
const inputValue = getSingleInputValue(connections, nodesData, 'inputHandle');
```

### Node Structure (MANDATORY):
```typescript
// REQUIRED: Every node must have this structure
const [showUI, setShowUI] = useState(false);

// REQUIRED: Toggle button pattern
<button onClick={() => setShowUI(!showUI)}>
  {showUI ? '⦿' : '⦾'}
</button>

// REQUIRED: Size classes
className={`${showUI ? 'w-[120px] h-[120px]' : 'w-[60px] h-[60px]'}`}
```

### Error Handling (AUTOMATIC):
```typescript
// Errors are automatically caught by global handler
// Just use console.error for node-specific errors
console.error(`Error in ${id}:`, error);
```

### Type Safety (ENFORCED):
```typescript
// REQUIRED: Proper TypeScript interfaces
interface YourNodeData {
  property: string;
  // All properties must be defined
}

// REQUIRED: Add to AgenNode union type
export type AgenNode =
  | (Node<YourNodeData & Record<string, unknown>> & { type: 'yourNodeType' })
  | // ... existing types
```

## 🎨 UI Best Practices

### Consistent Styling:
- Use Tailwind CSS classes for consistency
- Follow the established color scheme for handles
- Implement proper dark/light mode support
- Use the standard toggle button pattern

### Accessibility:
- Add proper ARIA labels
- Ensure keyboard navigation works
- Use semantic HTML elements
- Provide clear visual feedback

### Performance:
- Use React.memo for expensive components
- Implement useCallback for event handlers
- Use useMemo for computed values
- Avoid unnecessary re-renders

## 🧪 Testing Strategy

### Unit Tests:
- Test individual node components
- Test utility functions
- Test custom hooks
- Mock ReactFlow dependencies

### Integration Tests:
- Test node creation flow
- Test drag and drop functionality
- Test node connections
- Test state management

### Example Test:
```typescript
import { render, screen } from '@testing-library/react';
import YourNode from '../YourNode';

test('renders node with correct initial state', () => {
  const mockData = { yourProperty: 'test' };
  render(<YourNode id="test" data={mockData} />);
  
  expect(screen.getByText('⦾')).toBeInTheDocument();
});
```

## 📊 Performance Optimizations

The new modular architecture provides several performance benefits:

- **Targeted re-renders**: Only affected components update
- **Code splitting**: Lazy load node components
- **Memory efficiency**: Better garbage collection
- **Bundle optimization**: Smaller initial bundle size

## 🔄 Migration Benefits

Compared to the previous monolithic approach:

- **87% reduction** in lines per file (748 → ~100 average)
- **Clear separation** of concerns
- **Easy to test** individual components
- **Simple to extend** with new node types
- **Better maintainability** with focused modules
- **Type-safe** with comprehensive TypeScript

## 🚨 Critical AI Warnings

**THESE WILL BREAK THE SYSTEM - AVOID AT ALL COSTS:**

1. **🔴 NEVER skip any of the 6 registration steps** - Missing even one breaks the node completely
2. **🔴 NEVER modify monolithic files** - They don't exist anymore, use modular structure
3. **🔴 NEVER create custom state management** - Use established useReactFlow pattern
4. **🔴 NEVER ignore TypeScript errors** - All types must be properly defined
5. **🔴 NEVER use different sizing patterns** - Stick to 60x60px / 120x120px standard
6. **🔴 NEVER create nodes without proper handles** - Use CustomHandle with correct dataType
7. **🔴 NEVER forget the toggle button** - Required UI pattern for all nodes
8. **🔴 NEVER use different import paths** - Follow established module structure

## ✅ AI Success Checklist

Before completing any node creation task:

- [ ] All 6 registration steps completed
- [ ] TypeScript compiles without errors  
- [ ] Node appears in sidebar
- [ ] Drag and drop works
- [ ] Toggle button functions
- [ ] Handles connect properly
- [ ] Node inspector shows controls
- [ ] Data persists on refresh

## 📚 Additional Resources

- [ReactFlow Documentation](https://reactflow.dev/)
- [TypeScript Best Practices](https://typescript-eslint.io/rules/)
- [React Performance Optimization](https://react.dev/learn/render-and-commit)
- [Testing React Components](https://testing-library.com/docs/react-testing-library/intro/)

---

## 🎯 AI Summary

**REMEMBER**: This is a **modular architecture**. The old monolithic approach is completely obsolete.

**ALWAYS**:
- Follow the 6-step node creation process exactly
- Use the established patterns and utilities
- Maintain strict TypeScript compliance
- Reference `creating-new-nodes.md` for detailed examples
- Test thoroughly using the success checklist

**NEVER**:
- Skip registration steps
- Create custom patterns when established ones exist
- Modify large files (they've been modularized)
- Ignore TypeScript errors

The modular architecture makes it easy to add new functionality while maintaining code quality and performance. Every component has a single responsibility and clear interfaces.

